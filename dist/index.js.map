{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["// Datastar Attribute Plugin: data-on-keys\n// Custom attribute to bind actions to key presses\n\nimport type { AttributePlugin } from 'datastar/library/src/engine/types'\n\n// Auto-register with datastar if available from importmap\nif (typeof window !== 'undefined') {\n    // Try to import datastar dynamically if it's available via importmap\n    (async () => {\n        try {\n            // @ts-ignore - datastar may be available via importmap at runtime\n            const datastar = await import('datastar')\n            if (datastar?.attribute) {\n                datastar.attribute(onKeysPlugin(datastar.beginBatch, datastar.endBatch))\n            }\n        } catch (e) {\n            // Datastar not available via importmap, plugin needs manual registration\n        }\n    })()\n}\n\n// Helper function to parse key combinations\nfunction parseKeyCombo(keyCombo: string): { key: string; modifiers: { ctrl?: boolean; alt?: boolean; shift?: boolean; meta?: boolean } } {\n    // Use - for key combinations: ctrl-k\n    const parts = keyCombo.toLowerCase().split('-').map(p => p.trim());\n    const modifiers: { ctrl?: boolean; alt?: boolean; shift?: boolean; meta?: boolean } = {};\n    let key = '';\n\n    for (const part of parts) {\n        switch (part) {\n            case 'ctrl':\n            case 'control':\n                modifiers.ctrl = true;\n                break;\n            case 'alt':\n                modifiers.alt = true;\n                break;\n            case 'shift':\n                modifiers.shift = true;\n                break;\n            case 'meta':\n            case 'cmd':\n            case 'command':\n                modifiers.meta = true;\n                break;\n            default:\n                key = part;\n                break;\n        }\n    }\n\n    return { key, modifiers };\n}\n\n// Helper function to normalize key names\nfunction normalizeKey(key: string): string {\n    // For single letter keys, keep them as-is (lowercase)\n    if (key.length === 1 && /[a-z]/.test(key)) {\n        return key;\n    }\n    \n    const capitalized = key.charAt(0).toUpperCase() + key.slice(1).toLowerCase();\n    const keyMap: Record<string, string> = {\n        'Space': ' ',\n        'Return': 'Enter',\n        'Esc': 'Escape',\n        'Del': 'Delete',\n        'Pageup': 'PageUp',\n        'Pagedown': 'PageDown',\n        'Up': 'ArrowUp',\n        'Down': 'ArrowDown',\n        'Left': 'ArrowLeft',\n        'Right': 'ArrowRight',\n    };\n\n    return keyMap[capitalized] || capitalized;\n}\n\n// Helper function to check if event matches key combination\nfunction matchesKeyCombo(event: KeyboardEvent, keyCombo: string): boolean {\n    const { key, modifiers } = parseKeyCombo(keyCombo);\n    \n    // Normalize both the target key and the event key\n    const eventKey = event.key;\n    const targetKey = normalizeKey(key);\n    \n    if (eventKey !== targetKey) {\n        return false;\n    }\n\n    // Check modifiers\n    if (!!modifiers.ctrl !== event.ctrlKey) return false;\n    if (!!modifiers.alt !== event.altKey) return false;\n    if (!!modifiers.shift !== event.shiftKey) return false;\n    if (!!modifiers.meta !== event.metaKey) return false;\n\n    return true;\n}\n\nexport default function onKeysPlugin(beginBatch: () => void, endBatch: () => void): AttributePlugin {\n    return {\n        name: 'on-keys',\n        requirement: {\n            value: 'must',\n        },\n        argNames: ['evt'],\n        returnsValue: true,\n        apply({ el, key, mods, rx }: { el: Element; key: string; mods: Map<string, Set<string>>; rx: (event?: Event) => void }) {\n            // Parse key combinations from the key parameter\n            // Support formats like: \"esc\", \"alt-q\", \"ctrl-shift-s\", \"esc.alt-q.enter\"\n            const keySpecs = key ? key.split('.').map((k: string) => k.trim()) : [];\n            \n            // Default to window target, use element only when __el modifier is present\n            let target: Element | Window | Document = window;\n            if (mods.has('el')) target = el;\n            \n            // Create callback that replicates the exact behavior of datastar's on plugin\n            let callback = (evt?: Event) => {\n                if (evt) {\n                    // Only check key matching for keyboard events\n                    if (!(evt instanceof KeyboardEvent)) {\n                        return;\n                    }\n                    // Check if any of the specified key combinations match\n                    let shouldTrigger = false;\n                    \n                    if (keySpecs.length === 0) {\n                        // If no specific keys specified, trigger on any key\n                        shouldTrigger = true;\n                    } else {\n                        // Check each key specification\n                        for (const keySpec of keySpecs) {\n                            if (matchesKeyCombo(evt, keySpec)) {\n                                shouldTrigger = true;\n                                break;\n                            }\n                        }\n                    }\n                     \n                    if (!shouldTrigger) {\n                        return;\n                    }\n\n                    // Prevent default behavior by default, unless noprevent modifier is used\n                    if (!mods.has('noprevent') && typeof key !== 'undefined') {\n                        evt.preventDefault();\n                    }\n                    if (mods.has('stop')) {\n                        evt.stopPropagation();\n                    }\n                }\n                \n                beginBatch();\n                rx(evt);\n                endBatch();\n            }\n            \n            // Apply timing and view transition modifiers (same as datastar's on plugin)\n            // Currently these are not exported\n            // callback = modifyViewTransition(callback, mods);\n            // callback = modifyTiming(callback, mods);\n            \n            const evtListOpts: AddEventListenerOptions = {\n                capture: mods.has('capture'),\n                passive: mods.has('passive'),\n                once: mods.has('once'),\n            }\n            const eventType = mods.has('up') ? 'keyup' : 'keydown';\n            \n            target.addEventListener(eventType, callback, evtListOpts);\n            return () => {\n                target.removeEventListener(eventType, callback, evtListOpts);\n            }\n        }\n    } as AttributePlugin;\n}\n"],
  "mappings": "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",
  "names": ["datastar", "onKeysPlugin", "parseKeyCombo", "keyCombo", "parts", "p", "modifiers", "key", "part", "normalizeKey", "capitalized", "matchesKeyCombo", "event", "eventKey", "targetKey", "beginBatch", "endBatch", "el", "mods", "rx", "keySpecs", "k", "target", "callback", "evt", "shouldTrigger", "keySpec", "evtListOpts", "eventType"]
}
